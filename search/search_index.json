{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Melusine","text":""},{"location":"#overview","title":"Overview","text":"<p>Discover Melusine, a comprehensive email processing library designed to optimize your email workflow. Leverage Melusine's advanced features to achieve:</p> <ul> <li>Effortless Email Routing: Ensure emails reach their intended destinations with high accuracy.</li> <li>Smart Prioritization: Prioritize urgent emails for timely handling and efficient task management.</li> <li>Snippet Summaries: Extract relevant information from lengthy emails, saving you precious time and effort.</li> <li>Precision Filtering: Eliminate unwanted emails from your inbox, maintaining focus and reducing clutter.</li> </ul> <p>Melusine facilitates the integration of deep learning frameworks (HuggingFace, Pytorch, Tensorflow, etc.),  deterministic rules (regex, keywords, heuristics) into a full email qualification workflow.</p>"},{"location":"#why-choose-melusine","title":"Why Choose Melusine?","text":"<p>Melusine stands out with its combination of features and advantages:  </p> <ul> <li>Out-of-the-box features: Melusine comes with features such as<ul> <li>Segmenting an email conversation into individual messages.</li> <li>Tagging message parts (Email body, signatures, footers, etc.).</li> <li>Transferred email handling.</li> </ul> </li> <li>Streamlined Execution: Focus on the core email qualification logic while Melusine handles the boilerplate code, providing debug mode, pipeline execution, code parallelization, and more.</li> <li>Flexible Integrations: Melusine's modular architecture enables seamless integration with various AI frameworks, ensuring compatibility with your preferred tools.</li> <li>Production ready: Proven in the MAIF production environment, Melusine provides the robustness and stability you need.</li> </ul>"},{"location":"#email-segmentation-example","title":"Email Segmentation Example","text":"<p>In the following example, an email is divided into two distinct messages separated by a transition pattern.  Each message is then tagged line by line.  This email segmentation can later be leveraged to enhance the performance of machine learning models.</p> Message 1 <p><p> Dear Kim  HELLO </p> <p> Please find the details in the forwarded email.  BODY </p> <p> Best Regards  GREETINGS </p> <p> Jo Kahn  SIGNATURE </p></p> Transition pattern <p><p>Forwarded by jo@maif.fr on Monday december 12th  TRANSITION </p> <p>From: alex@gmail.com  TRANSITION </p> <p>To: jo@maif.fr  TRANSITION </p> <p>Subject: New address  TRANSITION </p></p> Message 2 <p><p> Dear Jo  HELLO </p> <p> A new version of Melusine is about to be released.  BODY </p> <p> Feel free to test it and send us feedbacks!  BODY </p> <p> Thank you for your help.  THANKS </p> <p> Cheers  GREETINGS </p> <p> Alex Leblanc  SIGNATURE </p> <p> 55 Rue du Faubourg Saint-Honor\u00e9  SIGNATURE </p> <p> 75008 Paris  SIGNATURE </p> <p> Sent from my iPhone  FOOTER </p></p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Get started with Melusine following our (tested!) tutorials:</p> <ul> <li>Getting Started</li> <li>MelusinePipeline</li> <li>MelusineTransformers</li> <li>MelusineRegex</li> <li>ML models</li> <li>MelusineDetector</li> <li>Configurations</li> <li>Basic Classification</li> </ul> <p>With Melusine, you're well-equipped to transform your email handling, streamlining processes, maximizing efficiency, and enhancing overall productivity.</p>"},{"location":"advanced/ContentTagger/","title":"Use custom message tags","text":""},{"location":"advanced/CustomDetector/","title":"Use a custom MelusineDetector template","text":""},{"location":"advanced/CustomDetector/#specify-abstract-methods","title":"Specify abstract methods","text":""},{"location":"advanced/CustomDetector/#row-transformations-vs-dataframe-transformations","title":"Row transformations vs dataframe transformations","text":""},{"location":"advanced/ExchangeConnector/","title":"Connect melusine to a Microsoft Exchange Mailbox","text":""},{"location":"advanced/GmailConnector/","title":"Connect Melusine to a Gmail Mailbox","text":"<p>The Gmail connector has been developed to make it easier to get started with Melusine, by connecting directly to your mailbox. The <code>GmailConnector</code> class allows:</p> <ul> <li>connect to your Gmail inbox</li> <li>retrieve the latest messages, filtering by date and labels</li> <li>extract relevant information from an e-mail, including attachments</li> <li>move messages individually into labels</li> <li>route an entire dataframe of e-mails to new labels, according to your detected use cases</li> <li>send emails</li> </ul>"},{"location":"advanced/GmailConnector/#installation","title":"Installation","text":"<p>First make sure to have a Gmail account and follow this medium tutorial to get your <code>credentials.json</code> file or follow as below.</p> Steps to create your credentials file from the medium post <ul> <li>Sign in to Google Cloud console and create a New Project or continue with an existing project.</li> <li>Go to APIs and Services.</li> <li>Go to Enable APIs and Services, enable Gmail API for the selected project.</li> <li>Clicking on OAuth Consent Screen to configure the content screen.</li> <li>Enter the Application name and save it.</li> <li>Now go to Credentials.</li> <li>Click on Create credentials, and go to OAuth Client ID.<ul> <li>Choose application type as Desktop Application.</li> <li>Enter the Application name, and click on the Create button.</li> <li>The Client ID will be created. Download it to your computer and save it as credentials.json</li> </ul> </li> <li>If the App is still in Testing mode, go to OAuth Consent Screen and add your gmail address to Test users.</li> </ul> <p>Once your <code>credentials.json</code> created, save it to root for the first use.</p>"},{"location":"advanced/GmailConnector/#usage","title":"Usage","text":""},{"location":"advanced/GmailConnector/#first-use","title":"First use","text":"<p>For the first use, a <code>token.json</code> will be created, save it. You will reuse it to sign in.</p> <pre><code>from melusine.connectors.gmail import GmailConnector\nimport logging\n# Set up logging\nch = logging.StreamHandler()\nformatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\nch.setFormatter(formatter)\nconnector_logger = logging.getLogger(\"melusine.connectors.gmail\")\nconnector_logger.addHandler(ch)\nconnector_logger.setLevel(logging.INFO)\nconnector = GmailConnector(credentials_json_path=\"/Users/xxxxx/melusine/credentials.json\")\n# &gt;&gt;&gt; 2024-05-06 11:18:58,636 - melusine.connectors.gmail - INFO - gmail token.json saved at: /Users/xxxxx/melusine\n# &gt;&gt;&gt; 2024-05-06 11:18:58,920 - melusine.connectors.gmail - INFO - Connected to mailbox: xxxxxxxxxx@gmail.com.\n# Next usage will then be:\nconnector = GmailConnector(token_json_path=\"/Users/xxxxx/melusine/token.json\")\n</code></pre> <p>Info</p> <p>A pop up window from google will ask you to choose your gmail account to sign in. If the app is still in testing mode, click on Continue. Then select all boxes to allow the credentials for read and modify rights, continue and close the window.</p>"},{"location":"advanced/GmailConnector/#get-emails","title":"Get emails","text":"<p>We have emails in the box to consider. These mails should either be put in Melusine label because they ask for something or in the TRASH label. Let's get the five last emails.</p> <pre><code>from melusine.connectors.gmail import GmailConnector\nconnector = GmailConnector(token_json_path=\"/Users/xxxxx/Desktop/melusine/token.json\", done_label=\"TRASH\")\ndf = connector.get_emails(max_emails=5)\n# equivalent to: \n# df = connector.get_emails(max_emails=5, target_labels= [\"INBOX\"])\nprint(df)\n</code></pre> message_id body header date from to attachment 1 12456789 This is a an example Demo1 Mon, 13 May 2024 07:31:09 +0000 test@example.com mybox@melusine.com [] 2 987654321 I am very happy of this Melusine connector Awesome connector!! Mon, 06 May 2024 10:55:22 +0000 connecting@people.com mybox@melusine.com [] 3 147258369 Does Melusine is free ? Impossible to believe Thu, 02 May 2024 12:40:28 +0000 melusine_fan@maif.com mybox@melusine.com [] 4 741852963 Hello World! print Mon, 29 Apr 2024 16:27:55 +0000 test@test.com mybox@melusine.com [] 5 951753467 Python is lovely PEP Thu, 25 Apr 2024 15:28:07 +0000 python@fan.com mybox@melusine.com [] <p>And that's it, you have your last 5 mails from the INBOX!</p> <p>Filters</p> <p>Filters can be used to get emails from specific labels. For example how about retrieveing emails unreaded in inbox from the last week? <pre><code>df = connector.get_emails(\nmax_emails=5,\ntarget_labels=[\"INBOX\", \"UNREAD\"],\nstart_date=\"2024/05/06\",\nend_date=\"2024/05/12\",\n)\n</code></pre></p> <p>Date format</p> <p>When using <code>start_date</code> and <code>end_date</code> from <code>get_emails</code>, the format of the dates needs to be <code>YYYY/MM/DD</code> eg 2024/03/31.</p>"},{"location":"advanced/GmailConnector/#create-label","title":"Create label","text":"<p>To route emails to labels, they must exist. Using the example above, let's create the Melusine label.</p> <pre><code>connector.create_label(\"Melusine\")\n# &gt;&gt;&gt; 2024-05-13 10:41:56,406 - melusine.connectors.gmail - INFO - Label Melusine has been created.\n# &gt;&gt;&gt; {'id': 'Label_4', 'name': 'Melusine', 'messageListVisibility': 'show', 'labelListVisibility': 'labelShow'}\n</code></pre> <p>The label has been created and it's id is <code>Label_4</code>.</p>"},{"location":"advanced/GmailConnector/#route-emails","title":"Route emails","text":"<p>There are two ways of routing emails, either individually using <code>move_to</code> or via the <code>route_emails</code> method, which takes as input a pandas data frame resulting from the application of the Melusine framework.</p>"},{"location":"advanced/GmailConnector/#route-using-melusine-output","title":"Route using Melusine output","text":"<p>Let's consider the same data frame, but with Melusine feedback to route each email via two detectors: TRASH and Melusine. The column of interest is <code>target.</code> and <code>classified_df</code> is:</p> message_id body ... attachment target 1 12456789 This is a an example ... [] TRASH 2 987654321 I am very happy of this Melusine connector ... [] Melusine 3 147258369 Does Melusine is free ? ... [] Melusine 4 741852963 Hello World! ... [] TRASH 5 951753467 Python is lovely ... [] TRASH <pre><code>connector.route_emails(classified_emails=classified_df)\n# &gt;&gt;&gt; 2024-05-13 10:48:43,752 - melusine.connectors.gmail - INFO - Moved 3 emails to 'TRASH' label\n# &gt;&gt;&gt; 2024-05-13 10:48:44,110 - melusine.connectors.gmail - INFO - Moved 2 emails to 'Melusine' label\n</code></pre>"},{"location":"advanced/GmailConnector/#route-one-by-one-not-recommanded","title":"Route one by one (not recommanded)","text":"<p>Considering the above data frame, the first emails is not related to Melusine so let's move it to trash. Conversely, the second evokes Melusine and should have the Melusine label.</p> <pre><code># First email\n# as done_label is \"TRASH\"\nconnector.move_to_done(emails_id=[df.iloc[0].message_id])\n# &gt;&gt;&gt; 2024-05-13 10:48:58,870 - melusine.connectors.gmail - INFO - Moved 1 emails to 'TRASH' label\n# Second email\nconnector.move_to(emails_id=[df.iloc[1].message_id], label_to_move_on=\"MELUSINE\")\n# &gt;&gt;&gt; 2024-05-13 10:48:59,110 - melusine.connectors.gmail - INFO - Moved 1 emails to 'Melusine' label\n</code></pre> <p>Info</p> <p>You can route multiple emails since <code>emails_id</code> from <code>move_to</code> and <code>move_to_done</code> is a list.</p>"},{"location":"advanced/PreTrainedModelsHF/","title":"Use pre-trained models from HuggingFace","text":""},{"location":"contribute/how_to_contribute/","title":"How to Contribute","text":"<p>Melusine welcomes contribution from every volunteer or developer that makes use of it.</p> <ul> <li>If you wish to contribute, please read the <code>CONTRIBUTING.md</code> (external link) file you will find in the code repository.</li> <li>If you found an issue or wish to request a new feature for Melusine, please file an issue on the issue tracker (external link).</li> </ul>"},{"location":"history/history/","title":"Project History","text":""},{"location":"history/history/#maif-origins","title":"MAIF Origins","text":"<p>Melusine, an open-source email processing library, was born at MAIF, a French mutual insurance company founded in 1934 and headquartered in Niort, France.  MAIF is committed to social and environmental responsibility, operating as a Soci\u00e9t\u00e9 \u00e0 mission (link in French) (label given to companies with social and environmental matters).</p>"},{"location":"history/history/#project-motivation","title":"Project Motivation","text":"<p>MAIF handles a vast volume of emails daily, necessitating an efficient processing solution to ensure timely and accurate handling while maximizing customer satisfaction. Automated email processing plays a crucial role in this endeavor, enabling tasks such as:</p> <ul> <li>Email routing: Redirecting emails to the most appropriate service for processing.</li> <li>Email prioritization: Prioritizing urgent emails for prompt attention.</li> <li>Email summarization: Extracting key information from emails for quick comprehension.</li> </ul>"},{"location":"history/history/#open-source-journey","title":"Open-Source Journey","text":"<p>After successfully implementing and testing the email processing code in production, MAIF made the strategic decision to open-source Melusine. </p> <p>This decision stems from multiple compelling reasons:</p> <ul> <li>Transparency: Open-sourcing the code fosters transparency with MAIF's customers, enabling them to understand how their emails are handled.</li> <li>Code quality: Adopting open-source quality standards promotes a culture of excellence and upskilling among MAIF developers.</li> <li>Benefiting from External Contributions: Open-source initiatives often attract contributions from external developers, expanding the pool of expertise and enhancing Melusine's capabilities.</li> <li>Building a Community: Engaging with Melusine users fosters a community of shared knowledge, best practices, and use-cases.</li> <li>Demonstrating Expertise: Open-sourcing Melusine showcases the MAIF DataFactory's technical expertise and commitment to innovation.</li> </ul>"},{"location":"history/history/#refactoring-and-advancement","title":"Refactoring and Advancement","text":"<p>The initial release of Melusine in 2019 followed its successful deployment at MAIF.  Since then, Melusine has evolved to meet the growing demands of MAIF's business needs.  In 2024, based on extensive feedback gained from Melusine's production usage, a complete refactoring effort resulted in the release of Melusine V3.  This latest version boasts enhanced modularity, customization options, seamless integration, robust monitoring capabilities, and simplified maintenance.</p>"},{"location":"philosophy/philosophy/","title":"Code philosophy","text":""},{"location":"philosophy/philosophy/#what-is-a-code-philosophy-and-why-do-i-need-it","title":"What is a code philosophy and why do I need it ?","text":""},{"location":"philosophy/philosophy/#design-patterns","title":"Design patterns","text":""},{"location":"tutorials/00_GettingStarted/","title":"Getting started with Melusine","text":"<p>Let's run emergency detection with Melusine:</p> <ul> <li>Load a fake email dataset</li> <li>Load a demonstration pipeline</li> <li>Run the pipeline  <ul> <li>Apply email cleaning transformations  </li> <li>Apply emergency detection</li> </ul> </li> </ul>"},{"location":"tutorials/00_GettingStarted/#input-data","title":"Input data","text":"<p>Email datasets typically contain information about:</p> <ul> <li>Email sender</li> <li>Email recipients</li> <li>Email subject/header</li> <li>Email body</li> <li>Attachments data</li> </ul> <p>The present tutorial only makes use of the body and header data.</p> body header 0 This is an \u00ebm\u00e8rg\u00e9n\u00e7y Help 1 How is life ? Hey ! 2 Urgent update about Mr. Annoying Latest news 3 Please call me now URGENT"},{"location":"tutorials/00_GettingStarted/#code","title":"Code","text":"<p>A typical code for a melusine-based application looks like this:</p> <pre><code>from melusine.data import load_email_data\nfrom melusine.pipeline import MelusinePipeline\n# Load an email dataset\ndf = load_email_data()\n# Load a pipeline\npipeline = MelusinePipeline.from_config(\"demo_pipeline\")  # (1)!\n# Run the pipeline\ndf = pipeline.transform(df)\n</code></pre> <ol> <li>This tutorial uses one of the default pipeline configuration <code>demo_pipeline</code>. Melusine users will typically define their own pipeline configuration.    See more in the Configurations tutorial</li> </ol>"},{"location":"tutorials/00_GettingStarted/#output-data","title":"Output Data","text":"<p>The pipeline created extra columns in the dataset. Some columns are temporary variables required by detectors (ex: <code>normalized_body</code>) and some are detection results with direct business value (ex: <code>emergency_result</code>).</p> body header normalized_body emergency_result 0 This is an \u00ebm\u00e8rg\u00e9n\u00e7y Help This is an emergency True 1 How is life ? Hey ! How is life ? False 2 Urgent update about Mr. Annoying Latest news Urgent update about Mr. Annoying False 3 Please call me now URGENT Please call me now True"},{"location":"tutorials/00_GettingStarted/#pipeline-steps","title":"Pipeline Steps","text":"<p>Illustration of the pipeline used in the present tutorial:</p> <pre><code>---\ntitle: Demonstration pipeline\n---\nflowchart LR\n    Input[[Email]] --&gt; A(Cleaner)\n    A(Cleaner) --&gt; C(Normalizer)\n    C --&gt; F(Emergency\\nDetector)\n    F --&gt; Output[[Qualified Email]]</code></pre> <ul> <li><code>Cleaner</code>: Cleaning transformations such as uniformization of line breaks (<code>\\r\\n</code> -&gt; <code>\\n</code>).</li> <li><code>Normalizer</code>: Text normalisation to delete/replace non utf8 characters (<code>\u00e9\u00f6\u00e0</code> -&gt; <code>eoa</code>).</li> <li><code>EmergencyDetector</code>: Detection of urgent emails.</li> </ul> <p>Info</p> <p>This demonstration pipeline is kept minimal but typical pipelines include more complex preprocessing and a variety of detectors. For example, pipelines may contain:</p> <ul> <li>Email Segmentation : Split email conversation into unitary messages</li> <li>ContentTagging : Associate tags (SIGNATURE, FOOTER, BODY) to parts of messages</li> <li>Appointment detection : For exemple, detect \"construction work will take place on 01/01/2024\" as an appointment email.</li> <li>More on preprocessing in the MelusineTransformers tutorial</li> <li>More on detectors in the MelusineDetector tutorial</li> </ul>"},{"location":"tutorials/00_GettingStarted/#debug-mode","title":"Debug Mode","text":"<p>End users typically want to know what lead melusine to a specific detection result. The debug mode generates additional explainability info.</p> <pre><code>from melusine.data import load_email_data\nfrom melusine.pipeline import MelusinePipeline\n# Load an email dataset\ndf = load_email_data()\n# Activate debug mode\ndf.debug = True\n# Load the default pipeline\npipeline = MelusinePipeline.from_config(\"demo_pipeline\")\n# Run the pipeline\ndf = pipeline.transform(df)\n</code></pre> <p>A new column <code>debug_emergency</code> is created.</p> ... emergency_result debug_emergency 0 ... True [details_below] 1 ... False [details_below] 2 ... False [details_below] 3 ... True [details_below] <p>Inspecting the debug data gives a lot of info:</p> <ul> <li><code>text</code>: Effective text considered for detection.</li> <li><code>EmergencyRegex</code>: melusine used an <code>EmergencyRegex</code> object to run detection.</li> <li><code>match_result</code>: The <code>EmergencyRegex</code> did not match the text.</li> <li><code>positive_match_data</code>: The <code>EmergencyRegex</code> matched positively the text pattern \"Urgent\" (Required condition).</li> <li><code>negative_match_data</code>: The <code>EmergencyRegex</code> matched negatively the text pattern \"Mr. Annoying\" (Forbidden condition).</li> <li><code>BLACKLIST</code>: Detection groups can be defined to easily link a matching pattern to the corresponding regex. DEFAULT is used if no detection group is specified.</li> </ul> <pre><code># print(df.iloc[2][\"debug_emergency\"])\n{\n'text': 'Latest news\\nUrgent update about Mr. Annoying'},\n'EmergencyRegex': {\n'match_result': False,\n'negative_match_data': {\n'BLACKLIST': [\n{'match_text': 'Mr. Annoying', 'start': 32, 'stop': 44}\n]},\n'neutral_match_data': {},\n'positive_match_data': {\n'DEFAULT': [\n{'match_text': 'Urgent', 'start': 12, 'stop': 18}\n]\n}\n}\n</code></pre>"},{"location":"tutorials/01_MelusinePipeline/","title":"MelusinePipeline","text":"<p>The <code>MelusinePipeline</code> class is at the core of Melusine. It inherits from the <code>sklearn.Pipeline</code> class and adds extra functionalities such as:</p> <ul> <li>Instantiation from configurations</li> <li>Input/output coherence check</li> <li>Debug mode</li> </ul>"},{"location":"tutorials/01_MelusinePipeline/#code","title":"Code","text":""},{"location":"tutorials/02_MelusineTransformers/","title":"MelusineTransformers","text":""},{"location":"tutorials/03_MelusineRegex/","title":"MelusineRegex","text":""},{"location":"tutorials/04_UsingModels/","title":"Using AI models","text":""},{"location":"tutorials/05a_MelusineDetectors/","title":"Melusine Detectors","text":"<p>The <code>MelusineDetector</code> component aims at standardizing how detection is performed in a <code>MelusinePipeline</code>. </p> <p>Tip</p> <p>Project running over several years (such as email automation)  may accumulate technical debt over time. Standardizing code practices  can limit the technical debt and ease the onboarding of new developers.</p> <p>The <code>MelusineDetector</code> class splits detection into three steps:</p> <ul> <li><code>pre_detect</code>: Select/combine the inputs needed for detection. For example, select the text parts tagged as <code>BODY</code> and combine them with the text of the email header.</li> <li><code>detect</code>: Use regular expressions, ML models or heuristics to run detection on the input text.</li> <li><code>post_detect</code>: Run detection rules such as thresholding or combine results from multiple models.</li> </ul> <p>The method <code>transform</code> is defined by the BaseClass <code>MelusineDetector</code> and will call the <code>pre_detect</code>/<code>detect</code>/<code>post_detect</code> methods in turn (Template pattern).</p> <pre><code># Instantiate Detector\ndetector = MyDetector()\n# Run pre_detect, detect and post_detect on input data\ndata_with_detection = detector.transform(data)\n</code></pre> <p>Here is the full code of a MelusineDetector to detect emails related to viruses.  The next sections break down the different parts of the code.</p> <pre><code>class MyCustomDetector(BaseMelusineDetector):\n@property\ndef transform_methods(self) -&gt; List[Callable]:\nreturn [self.prepare, self.run]\ndef prepare(self, row, debug_mode=False):\nreturn row\ndef run(self, row, debug_mode=False):\nrow[self.output_columns[0]] = \"12345\"\nreturn row\n</code></pre> <p>Here, the detector is run on a simple Pandas Dataframe:</p> <pre><code>df = pd.DataFrame(\n[\n{\"input_col\": \"test1\"},\n{\"input_col\": \"test2\"},\n]\n)\ndetector = MyCustomDetector(input_columns=[\"input_col\"], output_columns=[\"output_col\"], name=\"custom\")\ndf = detector.transform(df)\n</code></pre> <p>The output is a Dataframe with a new <code>virus_result</code> column.</p> body header virus_result 0 This is a dangerous virus test True 1 test test False 2 test viruses are dangerous True 3 corona virus is annoying test False <p>Tip</p> <p>Columns that are not declared in the <code>output_columns</code> are dropped automatically.</p>"},{"location":"tutorials/05a_MelusineDetectors/#detector-init","title":"Detector <code>init</code>","text":"<p>In the init method, you should call the superclass init and provide:</p> <ul> <li>A name for the detector</li> <li>Inputs columns</li> <li>Output columns</li> </ul> <p>Tip</p> <p>If the init method of the super class is enough (parameters <code>name</code>, <code>input_columns</code> and <code>output_columns</code>) you may skip the init method entirely when defining your <code>MelusineDetector</code>.</p>"},{"location":"tutorials/05a_MelusineDetectors/#detector-pre_detect","title":"Detector <code>pre_detect</code>","text":"<p>The <code>pre_detect</code> method simply combines the header text and the body text (separated by a line break).</p> <pre><code>def pre_detect(self, df, debug_mode=False):\n# Assemble the text columns into a single column\ndf[self.TMP_DETECTION_INPUT_COLUMN] = df[self.header_column] + \"\\n\" + df[self.body_column]\nreturn df\n</code></pre>"},{"location":"tutorials/05a_MelusineDetectors/#detector-detect","title":"Detector <code>detect</code>","text":"<p>The <code>detect</code> applies two regexes on the selected text: - A positive regex to catch mentions to viruses. - A negative regex to avoid false positive detections.</p> <pre><code>def detect(self, df, debug_mode=False):\ntext_column = df[self.TMP_DETECTION_INPUT_COLUMN]\npositive_regex = r\"(virus)\"\nnegative_regex = r\"(corona[ _]virus)\"\n# Pandas str.extract method on columns\ndf[self.TMP_POSITIVE_REGEX_MATCH] = text_column.str.extract(positive_regex).apply(pd.notna)\ndf[self.TMP_NEGATIVE_REGEX_MATCH] = text_column.str.extract(negative_regex).apply(pd.notna)\nreturn df\n</code></pre>"},{"location":"tutorials/05a_MelusineDetectors/#detector-post_detect","title":"Detector <code>post_detect</code>","text":"<p>The <code>post_detect</code> combines the regex detection result to determine the final result.</p> <pre><code>def post_detect(self, df, debug_mode=False):\n# Boolean operation on pandas column\ndf[self.OUTPUT_RESULT_COLUMN] = df[self.TMP_POSITIVE_REGEX_MATCH] &amp; ~df[self.TMP_NEGATIVE_REGEX_MATCH]\nreturn df\n</code></pre>"},{"location":"tutorials/05a_MelusineDetectors/#are-melusinedetectors-mandatory-for-melusine","title":"Are <code>MelusineDetectors</code> mandatory for melusine?","text":"<p>No.  </p> <p>You can use any <code>scikit-learn</code> compatible component in your <code>MelusinePipeline</code>.  However, we recommend using the <code>MelusineDetector</code> (and <code>MelusineTransformer</code>) classes to benefit from:</p> <ul> <li>Code standardization</li> <li>Input columns validation</li> <li>Dataframe backend variabilization. Today native Python dictionaries and <code>pandas</code> backend are supported but more backends may be added (e.g. <code>polars</code>)</li> <li>Debug mode</li> <li>Multiprocessing</li> </ul> <p>Check-out the next tutorial to discover advanced features of the <code>MelusineDetector</code> class.</p>"},{"location":"tutorials/05b_MelusineDetectorsAdvanced/","title":"Advanced Melusine Detectors","text":"<p>This tutorial presents the advanced features of the <code>MelusineDetector</code> class:</p> <ul> <li>Debug mode</li> <li>Row wise methods vs DataFrame wise methods</li> <li>Custom transform methods</li> </ul>"},{"location":"tutorials/05b_MelusineDetectorsAdvanced/#debug-mode","title":"Debug mode","text":"<p><code>MelusineDetector</code> are designed to be easily debugged. For that purpose, the <code>pre-detect</code>/<code>detect</code>/<code>post-detect</code> methods all have a <code>debug_mode</code> argument. The debug mode is activated by setting the <code>debug</code> attribute of a dataframe to <code>True</code>.</p> <pre><code>import pandas as pd\ndf = pd.DataFrame({\"bla\": [1, 2, 3]})\ndf.debug = True\n</code></pre> <p>Warning</p> <p>Debug mode activation is backend dependent. With a DictBackend, tou should use <code>my_dict[\"debug\"] = True</code></p> <p>When debug mode is activated, a column named <code>DETECTOR_NAME_debug</code> containing an empty dictionary is automatically created. Populating this debug dict with debug info is then left to the user's responsibility. </p> <p>Example of a detector with debug data:</p> <pre><code>class MyVirusDetector(MelusineDetector):\nOUTPUT_RESULT_COLUMN = \"virus_result\"\nTMP_DETECTION_INPUT_COLUMN = \"detection_input\"\nTMP_POSITIVE_REGEX_MATCH = \"positive_regex_match\"\nTMP_NEGATIVE_REGEX_MATCH = \"negative_regex_match\"\ndef __init__(self, body_column: str, header_column: str):\nself.body_column = body_column\nself.header_column = header_column\nsuper().__init__(\ninput_columns=[self.body_column, self.header_column],\noutput_columns=[self.OUTPUT_RESULT_COLUMN],\nname=\"virus\",\n)\ndef pre_detect(self, row, debug_mode=False):\neffective_text = row[self.header_column] + \"\\n\" + row[self.body_column]\nrow[self.TMP_DETECTION_INPUT_COLUMN] = effective_text\nif debug_mode:\nrow[self.debug_dict_col] = {\"detection_input\": row[self.TMP_DETECTION_INPUT_COLUMN]}\nreturn row\ndef detect(self, row, debug_mode=False):\ntext = row[self.TMP_DETECTION_INPUT_COLUMN]\npositive_regex = r\"virus\"\nnegative_regex = r\"corona[ _]virus\"\npositive_match = re.search(positive_regex, text)\nnegative_match = re.search(negative_regex, text)\nrow[self.TMP_POSITIVE_REGEX_MATCH] = bool(positive_match)\nrow[self.TMP_NEGATIVE_REGEX_MATCH] = bool(negative_match)\nif debug_mode:\npositive_match_text = (\npositive_match.string[positive_match.start() : positive_match.end()] if positive_match else None\n)\nnegative_match_text = (\npositive_match.string[negative_match.start() : negative_match.end()] if negative_match else None\n)\nrow[self.debug_dict_col].update(\n{\n\"positive_match_data\": {\"result\": bool(positive_match), \"match_text\": positive_match_text},\n\"negative_match_data\": {\"result\": bool(negative_match), \"match_text\": negative_match_text},\n}\n)\nreturn row\ndef post_detect(self, row, debug_mode=False):\nif row[self.TMP_POSITIVE_REGEX_MATCH] and not row[self.TMP_NEGATIVE_REGEX_MATCH]:\nrow[self.OUTPUT_RESULT_COLUMN] = True\nelse:\nrow[self.OUTPUT_RESULT_COLUMN] = False\nreturn row\n</code></pre> <p>In the end, an extra column is created containing debug data:</p> virus_result debug_virus 0 True {'detection_input': '...', 'positive_match_data': {'result': True, 'match_text': 'virus'}, 'negative_match_data': {'result': False, 'match_text': None}} 1 False {'detection_input': '...', 'positive_match_data': {'result': False, 'match_text': None}, 'negative_match_data': {'result': False, 'match_text': None}} 2 True {'detection_input': '...', 'positive_match_data': {'result': True, 'match_text': 'virus'}, 'negative_match_data': {'result': False, 'match_text': None}} 3 False {'detection_input': '...', 'positive_match_data': {'result': True, 'match_text': 'virus'}, 'negative_match_data': {'result': True, 'match_text': 'corona virus'}}"},{"location":"tutorials/05b_MelusineDetectorsAdvanced/#row-methods-vs-dataframe-methods","title":"Row Methods VS Dataframe Methods","text":"<p>There are two ways to use the <code>pre-detect</code>/<code>detect</code>/<code>post-detect</code> methods:</p> <ul> <li>Row wise: The method works on a single row of a <code>DataFrame</code>. In that case, a map-like method is used to apply it on an entire dataframe (typically <code>pandas.DataFrame.apply</code> is used with the PandasBackend).</li> <li>Dataframe wise: The method works directly on the entire DataFrame.</li> </ul> <p>Tip</p> <p>Using row wise methods make your code backend independent. You may  switch from a <code>PandasBackend</code> to a <code>DictBackend</code> at any time.  The <code>PandasBackend</code> also supports multiprocessing for row wise methods.</p> <p>To use row wise methods, you just need to name the first parameter of \"row\". Otherwise, dataframe wise transformations are used.</p> <p>Example of a Detector with dataframe wise method (works with a PandasBackend only).</p> <pre><code>class MyVirusDetector(MelusineDetector):\n\"\"\"\n    Detect if the text expresses dissatisfaction.\n    \"\"\"\n# Dataframe column names\nOUTPUT_RESULT_COLUMN = \"virus_result\"\nTMP_DETECTION_INPUT_COLUMN = \"detection_input\"\nTMP_POSITIVE_REGEX_MATCH = \"positive_regex_match\"\nTMP_NEGATIVE_REGEX_MATCH = \"negative_regex_match\"\ndef __init__(self, body_column: str, header_column: str):\nself.body_column = body_column\nself.header_column = header_column\nsuper().__init__(\ninput_columns=[self.body_column, self.header_column],\noutput_columns=[self.OUTPUT_RESULT_COLUMN],\nname=\"virus\",\n)\ndef pre_detect(self, df, debug_mode=False):\n# Assemble the text columns into a single column\ndf[self.TMP_DETECTION_INPUT_COLUMN] = df[self.header_column] + \"\\n\" + df[self.body_column]\nreturn df\ndef detect(self, df, debug_mode=False):\ntext_column = df[self.TMP_DETECTION_INPUT_COLUMN]\npositive_regex = r\"(virus)\"\nnegative_regex = r\"(corona[ _]virus)\"\n# Pandas str.extract method on columns\ndf[self.TMP_POSITIVE_REGEX_MATCH] = text_column.str.extract(positive_regex).apply(pd.notna)\ndf[self.TMP_NEGATIVE_REGEX_MATCH] = text_column.str.extract(negative_regex).apply(pd.notna)\nreturn df\ndef post_detect(self, df, debug_mode=False):\n# Boolean operation on pandas column\ndf[self.OUTPUT_RESULT_COLUMN] = df[self.TMP_POSITIVE_REGEX_MATCH] &amp; ~df[self.TMP_NEGATIVE_REGEX_MATCH]\nreturn df\n</code></pre>"},{"location":"tutorials/05b_MelusineDetectorsAdvanced/#custom-transform-methods","title":"Custom Transform Methods","text":"<p>If you are not happy with the <code>pre_detect</code>/<code>detect</code>/<code>post_detect</code> transform methods, you may: </p> <ul> <li>Use custom template methods.</li> <li> <p>Use regular pipeline steps (not inheriting from the <code>MelusineDetector</code> class).</p> </li> <li> <p>In this example, the <code>prepare</code>/<code>run</code> custom transform methods are used instead of the default <code>pre_detect</code>/<code>detect</code>/<code>post_detect</code>.</p> </li> </ul> <pre><code>class MyCustomDetector(BaseMelusineDetector):\n@property\ndef transform_methods(self) -&gt; List[Callable]:\nreturn [self.prepare, self.run]\ndef prepare(self, row, debug_mode=False):\nreturn row\ndef run(self, row, debug_mode=False):\nrow[self.output_columns[0]] = \"12345\"\nreturn row\n</code></pre> <p>To configure custom transform methods you need to: </p> <ul> <li>Inherit from the <code>melusine.base.BaseMelusineDetector</code> class.</li> <li>Define the <code>transform_methods</code> property.</li> </ul> <p>The <code>transform</code> method will now call <code>prepare</code> and <code>run</code>.</p> <pre><code>df = pd.DataFrame(\n[\n{\"input_col\": \"test1\"},\n{\"input_col\": \"test2\"},\n]\n)\ndetector = MyCustomDetector(input_columns=[\"input_col\"], output_columns=[\"output_col\"], name=\"custom\")\ndf = detector.transform(df)\n</code></pre> <p>We can check that the <code>run</code> method was indeed called.</p> input_col output_col 0 test1 12345 1 test2 12345"},{"location":"tutorials/06_Configurations/","title":"Configurations","text":"<p>Melusine components can be instantiated using parameters defined in configurations. The <code>from_config</code> method accepts a <code>config_dict</code> argument.</p> <pre><code>from melusine.processors import Normalizer\nnormalizer_conf = {\n\"input_columns\": [\"text\"],\n\"output_columns\": [\"normalized_text\"],\n\"form\": \"NFKD\",\n\"lowercase\": False,\n}\nnormalizer = Normalizer.from_config(config_dict=normalizer_conf)\n</code></pre> <p>Or a <code>config_key</code> argument.</p> <pre><code>from melusine.pipeline import MelusinePipeline\npipeline = MelusinePipeline.from_config(config_key=\"demo_pipeline\")\n</code></pre> <p>When <code>demo_pipeline</code> is given as argument, parameters are read from the <code>melusine.config</code> object at key <code>demo_pipeline</code>.</p>"},{"location":"tutorials/06_Configurations/#access-configurations","title":"Access Configurations","text":"<p>The melusine configurations can be accessed with the <code>config</code> object.</p> <pre><code>from melusine import config\nprint(config[\"demo_pipeline\"])\n</code></pre> <p>The configuration of the <code>demo_pipeline</code> can then be easily inspected.</p> <pre><code>{\n'steps': [\n{'class_name': 'Cleaner', 'config_key': 'body_cleaner', 'module': 'melusine.processors'},\n{'class_name': 'Cleaner', 'config_key': 'header_cleaner', 'module': 'melusine.processors'},\n{'class_name': 'Segmenter', 'config_key': 'segmenter', 'module': 'melusine.processors'},\n{'class_name': 'ContentTagger', 'config_key': 'content_tagger', 'module': 'melusine.processors'},\n{'class_name': 'TextExtractor', 'config_key': 'text_extractor', 'module': 'melusine.processors'},\n{'class_name': 'Normalizer', 'config_key': 'demo_normalizer', 'module': 'melusine.processors'},\n{'class_name': 'EmergencyDetector', 'config_key': 'emergency_detector', 'module': 'melusine.detectors'}\n]\n}\n</code></pre>"},{"location":"tutorials/06_Configurations/#modify-configurations","title":"Modify Configurations","text":"<p>The simplest way to modify configurations is to create a new directory directly.</p> <pre><code>from melusine import config\n# Get a dict of the existing conf\nnew_conf = config.dict()\n# Add/Modify a config key\nnew_conf[\"my_conf_key\"] = \"my_conf_value\"\n# Reset Melusine configurations\nconfig.reset(new_conf)\n</code></pre> <p>To deliver code in a production environment, using configuration files should be preferred to modifying the configurations on the fly. Melusine lets you specify the path to a folder containing <code>yaml</code> files and loads them (the <code>OmegaConf</code> package is used behind the scene).</p> <pre><code>from melusine import config\n# Specify the path to a conf folder\nconf_path = \"path/to/conf/folder\"\n# Reset Melusine configurations\nconfig.reset(config_path=conf_path)\n# &gt;&gt; Using config_path : path/to/conf/folder\n</code></pre> <p>When the <code>MELUSINE_CONFIG_DIR</code> environment variable is set, Melusine loads directly the configurations files located at the path specified by the environment variable.</p> <pre><code>import os\nfrom melusine import config\n# Specify the MELUSINE_CONFIG_DIR environment variable\nos.environ[\"MELUSINE_CONFIG_DIR\"] = \"path/to/conf/folder\"\n# Reset Melusine configurations\nconfig.reset()\n# &gt;&gt; Using config_path from env variable MELUSINE_CONFIG_DIR\n# &gt;&gt; Using config_path : path/to/conf/folder\n</code></pre> <p>Tip</p> <p>If the <code>MELUSINE_CONFIG_DIR</code> is set before melusine is imported (e.g., before starting the program), you don't need to call <code>config.reset()</code>. </p>"},{"location":"tutorials/06_Configurations/#export-configurations","title":"Export Configurations","text":"<p>Creating your configuration folder from scratch would be cumbersome. It is advised to export the default configurations and then modify just the files you need.</p> <pre><code>from melusine import config\n# Specify the path a folder (created if it doesn't exist)\nconf_path = \"path/to/conf/folder\"\n# Export default configurations to the folder\nfiles_created = config.export_default_config(path=conf_path)\n</code></pre> <p>Tip</p> <p>The <code>export_default_config</code> returns a list of path to all the files created. </p>"},{"location":"tutorials/07_BasicClassification/","title":"Zero Shot Classification","text":"<p>Machine Learning is commonly used to classify data into pre-defined categories. </p> <pre><code>---\ntitle: Email classification\n---\nflowchart LR\n    Input[[Email]] --&gt; X(((Classifier)))\n    X --&gt; A(Car)\n    X --&gt; B(Boat)\n    X --&gt; C(Housing)\n    X --&gt; D(Health)</code></pre> <p>Typically, to reach high classification performance,  models need to be trained on context specific labeled data.  Zero-shot classification is a type of classification that  uses a pre-trained model and does not require further training on context specific data.</p>"},{"location":"tutorials/07_BasicClassification/#tutorial-introduction","title":"Tutorial Introduction","text":"<p>In this tutorial we want to detect dissatisfaction in an email dataset. Let's create a basic dataset:</p> <pre><code>import pandas as pd\nfrom transformers import pipeline\nfrom melusine.base import MelusineDetector\ndef create_dataset():\ndf = pd.DataFrame(\n[\n{\n\"header\": \"Dossier 123456\",\n\"body\": \"Merci beaucoup pour votre gentillesse et votre \u00e9coute !\",\n},\n{\n\"header\": \"R\u00e9clamation (Dossier 987654)\",\n\"body\": (\"Bonjour, je ne suis pas satisfait de cette situation, \" \"r\u00e9pondez-moi rapidement svp!\"),\n},\n]\n)\nreturn df\n</code></pre> header body 0 Dossier 123456 Merci beaucoup pour votre gentillesse et votre \u00e9coute ! 1 R\u00e9clamation (Dossier 987654) Bonjour, je ne suis pas satisfait de cette situation, r\u00e9pondez-moi rapidement svp!"},{"location":"tutorials/07_BasicClassification/#classify-with-zero-shot-classification","title":"Classify with Zero-Shot-Classification","text":"<p>The <code>transformers</code> library, provided by HuggingFace, makes it really simple to use pre-trained models for zero shot classification.</p> <pre><code>model_name_or_path = \"cmarkea/distilcamembert-base-nli\"\nsentences = [\n\"Quelle belle journ\u00e9e aujourd'hui\",\n\"La mar\u00e9e est haute\",\n\"Ce film est une catastrophe, je suis en col\u00e8re\",\n]\nclassifier = pipeline(task=\"zero-shot-classification\", model=model_name_or_path, tokenizer=model_name_or_path)\nresult = classifier(\nsequences=sentences, candidate_labels=\", \".join([\"positif\", \"n\u00e9gatif\"]), hypothesis_template=\"Ce texte est {}.\"\n)\n</code></pre> <p>The classifier returns a score for the positive (positif in French) and negative (n\u00e9gatif in French) labels for each input text:</p> <pre><code>[\n{\n'sequence': \"Quelle belle journ\u00e9e aujourd'hui\",\n'labels': ['positif', 'n\u00e9gatif'],\n'scores': [0.95, 0.05]\n},\n{\n'sequence': 'La mar\u00e9e est haute',\n'labels': ['positif', 'n\u00e9gatif'],\n'scores': [0.76, 0.24]\n},\n{'sequence': 'Ce film est une catastrophe, je suis en col\u00e8re',\n'labels': ['n\u00e9gatif', 'positif'],\n'scores': [0.97, 0.03]\n}\n]\n</code></pre>"},{"location":"tutorials/07_BasicClassification/#implement-a-dissatisfaction-detector","title":"Implement a Dissatisfaction Detector","text":"<p>A full email processing pipeline may contain multiple models. Melusine uses the <code>MelusineDetector</code> template class to standardize how models are integrated into a pipeline.</p> <pre><code>class DissatisfactionDetector(MelusineDetector):\n\"\"\"\n    Detect if the text expresses dissatisfaction.\n    \"\"\"\n# Dataframe column names\nOUTPUT_RESULT_COLUMN = \"dissatisfaction_result\"\nTMP_DETECTION_INPUT_COLUMN = \"detection_input\"\nTMP_DETECTION_OUTPUT_COLUMN = \"detection_output\"\n# Model inference parameters\nPOSITIVE_LABEL = \"positif\"\nNEGATIVE_LABEL = \"n\u00e9gatif\"\nHYPOTHESIS_TEMPLATE = \"Ce texte est {}.\"\ndef __init__(self, model_name_or_path: str, text_columns: List[str], threshold: float):\nself.text_columns = text_columns\nself.threshold = threshold\nself.classifier = pipeline(\ntask=\"zero-shot-classification\", model=model_name_or_path, tokenizer=model_name_or_path\n)\nsuper().__init__(input_columns=text_columns, output_columns=[self.OUTPUT_RESULT_COLUMN], name=\"dissatisfaction\")\n</code></pre> <p>The <code>pre_detect</code> method assembles the text that we want to use for classification.</p> <pre><code>def pre_detect(self, row, debug_mode=False):\n# Assemble the text columns into a single text\neffective_text = \"\"\nfor col in self.text_columns:\neffective_text += \"\\n\" + row[col]\nrow[self.TMP_DETECTION_INPUT_COLUMN] = effective_text\n# Store the effective detection text in the debug data\nif debug_mode:\nrow[self.debug_dict_col] = {\"detection_input\": row[self.TMP_DETECTION_INPUT_COLUMN]}\nreturn row\n</code></pre> <p>The <code>detect</code> method runs the classification model on the text.</p> <pre><code>def detect(self, row, debug_mode=False):\n# Run the classifier on the text\npipeline_result = self.classifier(\nsequences=row[self.TMP_DETECTION_INPUT_COLUMN],\ncandidate_labels=\", \".join([self.POSITIVE_LABEL, self.NEGATIVE_LABEL]),\nhypothesis_template=self.HYPOTHESIS_TEMPLATE,\n)\n# Format classification result\nresult_dict = dict(zip(pipeline_result[\"labels\"], pipeline_result[\"scores\"]))\nrow[self.TMP_DETECTION_OUTPUT_COLUMN] = result_dict\n# Store ML results in the debug data\nif debug_mode:\nrow[self.debug_dict_col].update(result_dict)\nreturn row\n</code></pre> <p>The <code>post_detect</code> method applies a threshold on the prediction score to determine the detection result.</p> <pre><code>def post_detect(self, row, debug_mode=False):\n# Compare classification score to the detection threshold\nif row[self.TMP_DETECTION_OUTPUT_COLUMN][self.NEGATIVE_LABEL] &gt; self.threshold:\nrow[self.OUTPUT_RESULT_COLUMN] = True\nelse:\nrow[self.OUTPUT_RESULT_COLUMN] = False\nreturn row\n</code></pre> <p>On top of that, the detector takes care of building debug data to make the result explicable.</p>"},{"location":"tutorials/07_BasicClassification/#run-detection","title":"Run Detection","text":"<p>Putting it all together, we run the detector on the input dataset.</p> <pre><code>df = create_dataset()\ndetector = DissatisfactionDetector(\nmodel_name_or_path=\"cmarkea/distilcamembert-base-nli\",\ntext_columns=[\"header\", \"body\"],\nthreshold=0.7,\n)\ndf = detector.transform(df)\n</code></pre> <p>As a result, we get a new column <code>dissatisfaction_result</code> with the detection result.  We could have detection details by running the detector in debug mode.</p> header body dissatisfaction_result 0 Dossier 123456 Merci beaucoup pour votre gentillesse et votre \u00e9coute ! False 1 R\u00e9clamation (Dossier 987654) Bonjour, je ne suis pas satisfait de cette situation, r\u00e9pondez-moi rapidement svp! True"},{"location":"tutorials/08_MelusineRegex/","title":"Melusine Regexes","text":"<p>Let's say you are a very busy fairy handling the organisation of a lot of fairy stuff. You might want to apply a special king of magic named \"regex\" to your emails so that all the fairying goes smoothly.</p> <p>There are some things you want sent directly to the trash:</p> <ul> <li>That annoying Voldemort dude keeps sending his <code>Avada Kedavra</code> thingy, which tingles everytime you open it, let's delete it on sight.</li> <li>Gandalf sends all the memes about him and his stupid catchphrase, you don't really care about it and want it deleted as well.</li> </ul>"},{"location":"tutorials/08_MelusineRegex/#preparing-our-custom-melusineregex","title":"Preparing our custom MelusineRegex","text":"<p>So you heat up your cauldron and start by cooking the following <code>MelusineRegex</code></p> <pre><code>from melusine.base import MelusineRegex\nclass AnnoyingEmailsRegex(MelusineRegex):\n@property\ndef positive(self) -&gt; Union[str, Dict[str, str]]:\nreturn dict(\nVOLDY_BEING_VOLDY=\"Avada Kedavra\",\nGANDALF_BEING_GANDALF=\"You shall not pass\",\n)\n@property  # (1)!\ndef match_list(self) -&gt; List[str]:\nreturn [\n\"Avada Kedavra is a spell used by Lord Voldemort\",\n\"And then, you know me, I was not gonna let it pass so I told them : You shall not pass and obviously everyone clapped\",\n]\n@property  # (2)!\ndef no_match_list(self) -&gt; List[str]:\nreturn [\"Abracadabra, here I am\", \"I told them not to pass\"]\n</code></pre> <ol> <li>The code would not work without those, we'll see later how they are used</li> <li>The code would not work without those, we'll see later how they are used</li> </ol> <p>Let's use it on this incoming email.</p> <pre><code>to_delete_regex = AnnoyingEmailsRegex()\nto_delete_detection = to_delete_regex(\n\"You shall not pass through the magical portal of the lake from Monday to Thursday as it is currently under repair.\"\n)\nprint(to_delete_detection[MelusineRegex.MATCH_RESULT])  # (1)!\nprint(to_delete_detection[MelusineRegex.POSITIVE_MATCH_FIELD])  # (2)!\n</code></pre> <ol> <li>Prints <code>True</code></li> <li>Prints <code>{'GANDALF_BEING_GANDALF': [{'start': 0, 'stop': 18, 'match_text': 'You shall not pass'}]}</code></li> </ol> <p>The thing is, our email actually came from the Magical Portal Society and was pretty important. We should exclude any email mentionning the magical portal from detection to make sure we still get the important infos.</p>"},{"location":"tutorials/08_MelusineRegex/#using-both-negative-and-positive-matches","title":"Using both negative and positive matches","text":"<pre><code>from melusine.base import MelusineRegex\nclass AnnoyingEmailsRegex(MelusineRegex):\n@property\ndef positive(self) -&gt; Union[str, Dict[str, str]]:\nreturn dict(\nVOLDY_BEING_VOLDY=\"Avada Kedavra\",\nGANDALF_BEING_GANDALF=\"You shall not pass\",\n)\n@property\ndef negative(self) -&gt; Union[str, Dict[str, str]]:\nreturn dict(\nPORTAL_MENTIONNED=\"magical portal of the lake\",\n)\n@property  # (1)!\ndef match_list(self) -&gt; List[str]:\nreturn [\n\"Avada Kedavra is a spell used by Lord Voldemort\",\n\"And then, you know me, I was not gonna let it pass so I told them : You shall not pass and obviously everyone clapped\",\n]\n@property  # (2)!\ndef no_match_list(self) -&gt; List[str]:\nreturn [\"Abracadabra, here I am\", \"I told them not to pass\"]\n</code></pre> <p>And now the Regex works as follows</p> <pre><code>to_delete_regex = AnnoyingEmailsRegex()\nemail = \"You shall not pass through the magical portal of the lake from Monday to Thursday as it is currently under repair.\"\nto_delete_detection = to_delete_regex(email)\nprint(to_delete_detection[MelusineRegex.MATCH_RESULT])  # (1)!\n</code></pre> <ol> <li>Prints <code>False</code></li> </ol>"},{"location":"tutorials/08_MelusineRegex/#preprocessing","title":"Preprocessing","text":"<p>Now, you know that old geezer of Gandalf, he tends to mispell words often.</p> <p>So you want to make sure you detect any of his hobbit-feast-greasy-fingers-written emails too.</p> <p>With a pinch of preprocessing, it's easy to do!</p> <pre><code>class PreMatchHookAnnoyingEmailsRegex(AnnoyingEmailsRegex):\ndef pre_match_hook(self, text: str) -&gt; str:\ntext = text.replace(\"sholl not pass\", \"shall not pass\")\nreturn text\npreprocessed_to_delete_regex = PreMatchHookAnnoyingEmailsRegex()\nspell_result = preprocessed_to_delete_regex.get_match_result(\n\"Andthen,, I told Morgana 'You sholl not pass!' as she wanted topass... Im stil wonddering why she did not find it fundny...\"\n)\n</code></pre>"},{"location":"tutorials/08_MelusineRegex/#using-the-regex-result","title":"Using the regex result","text":"<p>As you can see, the negative cancels the positive, hence this email was not detected. The complete <code>to_delete_detection</code> object looks like this:</p> <pre><code>{\n\"match_result\":False,\n\"neutral_match_data\":{\n},\n\"negative_match_data\":{\n\"PORTAL_MENTIONNED\":[\n{\n\"start\":31,\n\"stop\":57,\n\"match_text\":\"magical portal of the lake\"\n}\n]\n},\n\"positive_match_data\":{\n\"GANDALF_BEING_GANDALF\":[\n{\n\"start\":0,\n\"stop\":18,\n\"match_text\":\"You shall not pass\"\n}\n]\n}\n}\n</code></pre> <p>For a more straightforward approach, if you only need the regex result, you can use the following syntax:</p> <p><pre><code>spell_analysis_result: bool = to_delete_regex.get_match_result(email)  # (1)!\n</code></pre> 1. Returns <code>True</code> Some of the older fairies might need a more detailed explanation on what triggered the deletion of an email. Fortunately the describe methode serves this exact purpose.</p> <pre><code>to_delete_regex.describe(email)\n</code></pre> <p>Which will print:</p> <p>The MelusineRegex match result is : NEGATIVE</p> <p>The following text matched negatively: (PORTAL_MENTIONNED) magical portal of the lake</p> <p>The following text matched positively: (GANDALF_BEING_GANDALF) You shall not pass</p>"},{"location":"tutorials/08_MelusineRegex/#examples-list","title":"Examples list","text":"<p>Fairies social life can be hectic resulting in a variety of emails from all kinds of creatures. Like most magical artefacts, regexes can be quite obscure and hard to decipher. This is where the <code>match_list</code> and <code>no_match_list</code> properties come in handy:  </p> <ul> <li>Examples in the <code>match_list</code> should activate the MelusineRegex</li> <li>Examples in the <code>no_match_list</code> should not activate the MelusineRegex</li> </ul> <p>The <code>test</code> method will be run at instanciation to check if the regex is working as intended.</p> <pre><code>from melusine.base import MelusineRegex\nclass AnnoyingEmailsRegex(MelusineRegex):\n@property\ndef positive(self) -&gt; Union[str, Dict[str, str]]:\nreturn dict(\nVOLDY_BEING_VOLDY=\"Avada Kedavra\",\nGANDALF_BEING_GANDALF=\"You shall not pass\",\n)\n@property\ndef match_list(self) -&gt; List[str]:\nreturn [\n\"Avada Kedavra is a spell used by Lord Voldemort\",  # (1)!\n\"Erroneous example: This will not match!\",  # (2)!\n]\n@property\ndef no_match_list(self) -&gt; List[str]:\nreturn [\"Abracadabra, here I am\", \"I told them not to pass\"]\nregex = AnnoyingEmailsRegex()  # (3)!\n</code></pre> <ol> <li>This example is aligned with the regex (activates a positive pattern and doesn't trigger any negative pattern).</li> <li>This example is not aligned with the regex (doesn't activate any positive pattern).</li> <li>This will raise an error as the second example in the <code>match_list</code> will not match.</li> </ol>"},{"location":"tutorials/08_MelusineRegex/#even-more-advanced-use-case-with-neutral","title":"Even more advanced use case with \"neutral\"","text":"<p>As a fairy preserving the balance of the world and all, another case you would like to handle is differentiating your colleague Ifrit's emails between dangerous or not. Contrarly to him you actually like the not-yet-totally-burning state of the world and would rather keep it that way.</p> <p>But you cannot afford to go all-in everytime he jokingly sends false alarms emails. </p> <p>The good thing is that Ifrit is a bit of a dummy: </p> <ul> <li>whevener he wants to burn the world for real and needs to be stopped he sends you an email with his intentions.</li> <li>if he is actually joking, the emails uses contractions which make his intentions super easy to guess (he is not just \"a bit\" of a dummy, he can be plain stupid sometimes).</li> </ul> <p>That is were neutral regex can be of use. Whenever a neutral regex is matched, it is neutralized: all the match content is \"blurred\" and won't match anything later.</p> <pre><code>class IfritAlertRegex(MelusineRegex):\n@property\ndef positive(self) -&gt; Union[str, Dict[str, str]]:\nreturn dict(\nWORLD_MIGHT_BURN_1=r\"see (the world|everything) (burn|in flames)\",\nWORLD_MIGHT_BURN_2=r\"make (the world|everything) (burn|in flames)\",\n)\n@property\ndef neutral(self) -&gt; Union[str, Dict[str, str]]:\nreturn dict(\nWORLD_WONT_BURN_1=r\"I wanna see (the world|everything) (burn|in flames)\",\nWORLD_WONT_BURN_2=r\"Imma make (the world|everything) (burn|in flames)\",\nWORLD_WONT_BURN_3=r\"I wanna make (the world|everything) (burn|in flames)\",\n)\n@property\ndef match_list(self) -&gt; List[str]:\nreturn [\n\"I want to see the world burn\",\n\"Let us make the world burn, shall we\",\n\"I wanna make the world burn and see everything in flames\",  # (1)!\n]\n@property\ndef no_match_list(self) -&gt; List[str]:\nreturn [\"I wanna see the world burn\", \"Imma make everything in flames\"]\n</code></pre> <ol> <li>In this specific case, neutral will come into action first and blur \"I wanna make the world burn\" but \"see everything burn\" will still match</li> </ol>"},{"location":"tutorials/08_MelusineRegex/#conclusion","title":"Conclusion","text":"<ul> <li>The <code>MelusineRegex</code> class is a convenient tool to keep regexes clean, documented and easy to use.    </li> <li>Advanced features like \"pre\" and \"post\" match hooks bring flexibility to accommodate exotic use cases.  </li> <li>The <code>match_list</code> and <code>no_match_list</code> help onboard newcomers on what the regex does.  </li> <li>The <code>test</code> method is a great way to ensure the regex is working as intended.  </li> </ul> <p>Now you can go back to your fairy duties and let the regex do the heavy lifting for you.</p>"}]}